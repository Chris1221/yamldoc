{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Documentation Engine for YAML This package converts a YAML file into markdown, formatting values and associated metadata in a doxygen -like way. Installation pip install yamldoc This will install the python package, which contains a command line interface yamldoc . To see usage instructions, invoke the --help flag: yamldoc -h Philosophy Many programs and utilities use YAML ( YAML Ain't Markup Language ) as a human and machine readable interface to configuration parameters and other values. More broadly, many kinds of data can be stored in YAML with minimal effort from the user. However, often a configuration file accumulates a highly specific set of configurations marked up with vague, difficult to interpret comments. It is the goal of this package to provide an easy interface for developers to document data in their YAML files as well as the expected types from a JSON YAML schema validator . Doing so will allow a transparent interface between the developer's expectations and the user's configurations. Specific Application to Snakemake This package was designed specifically to document the possible configuration options of a Snakemake pipeline. In this application, the developer of the pipeline encodes many different specific options that the user may configure at run time, but these are often poorly documented. When they are, it is easy for the documentation to fall out of sync with the actual options in the configuration file. yamldoc automatically documents all configuration paramters as well as taking types from a schema file. The package will also read any comments that are present above each paramter and insert them into a parameter table for easy reference. For more details on using YAML to configure Snakemake pipelines, see here . Example Files For a minimal example of yamldoc , see the files in /test/yaml and /test/schema . Usage For a basic report, point the command line interface to a YAML file. yamldoc test/yaml/basic.yaml You can also include type information from a schema file. yamldoc test/yaml/basic.yaml -s test/schema/basic.schema Other Options yamldoc defaults to using #' as a special marker, but you can choose this character yourself if you wish. Just set it on the command line at parse-time: yamldoc test/yaml/basic.yaml -c \"YOURCHAR\" yamldoc also includes support for certain special declarations in the schema file. Right now these include: _yamldoc_title : This specifies the overall title of the markdown page generated. _yamldoc_description : A description to follow the title. These are picked out of the schema file and reported.","title":"Overview"},{"location":"#documentation-engine-for-yaml","text":"This package converts a YAML file into markdown, formatting values and associated metadata in a doxygen -like way.","title":"Documentation Engine for YAML"},{"location":"#installation","text":"pip install yamldoc This will install the python package, which contains a command line interface yamldoc . To see usage instructions, invoke the --help flag: yamldoc -h","title":"Installation"},{"location":"#philosophy","text":"Many programs and utilities use YAML ( YAML Ain't Markup Language ) as a human and machine readable interface to configuration parameters and other values. More broadly, many kinds of data can be stored in YAML with minimal effort from the user. However, often a configuration file accumulates a highly specific set of configurations marked up with vague, difficult to interpret comments. It is the goal of this package to provide an easy interface for developers to document data in their YAML files as well as the expected types from a JSON YAML schema validator . Doing so will allow a transparent interface between the developer's expectations and the user's configurations.","title":"Philosophy"},{"location":"#specific-application-to-snakemake","text":"This package was designed specifically to document the possible configuration options of a Snakemake pipeline. In this application, the developer of the pipeline encodes many different specific options that the user may configure at run time, but these are often poorly documented. When they are, it is easy for the documentation to fall out of sync with the actual options in the configuration file. yamldoc automatically documents all configuration paramters as well as taking types from a schema file. The package will also read any comments that are present above each paramter and insert them into a parameter table for easy reference. For more details on using YAML to configure Snakemake pipelines, see here .","title":"Specific Application to Snakemake"},{"location":"#example-files","text":"For a minimal example of yamldoc , see the files in /test/yaml and /test/schema .","title":"Example Files"},{"location":"#usage","text":"For a basic report, point the command line interface to a YAML file. yamldoc test/yaml/basic.yaml You can also include type information from a schema file. yamldoc test/yaml/basic.yaml -s test/schema/basic.schema","title":"Usage"},{"location":"#other-options","text":"yamldoc defaults to using #' as a special marker, but you can choose this character yourself if you wish. Just set it on the command line at parse-time: yamldoc test/yaml/basic.yaml -c \"YOURCHAR\" yamldoc also includes support for certain special declarations in the schema file. Right now these include: _yamldoc_title : This specifies the overall title of the markdown page generated. _yamldoc_description : A description to follow the title. These are picked out of the schema file and reported.","title":"Other Options"},{"location":"hier_tutorial/","text":"yamldoc also includes support for a maximum of two levels deep hierarchical representations of data . For examples, see test/yaml/two_level.yaml and test/schema/two_level.schema . The program is run the same way.","title":"Hierarchical YAML"},{"location":"sphinx/","text":"Sphinx Integration A primary motivation for yamldoc was to generate documentation for YAML configuration files dynamically, in order that documentation does not outpace development. I have plans to include yamldoc in a Sphinx extension in the future, but for now there is a simple way to generate your parameter references with each build of the documentation. Sphinx Setup For this example, we have chosen to place our Sphinx documentation in the docs/ folder. Inside this folder is a directory for the source scripts, a directory for the built HTML files (if building a website), and a Makefile . You must first install some sort of Markdown parser so that the markdown that is produced from yamldoc can be understood by Sphinx. For this we recommend recommonmark . Since there is no support for markdown style tables in this package, you have to also install sphinx-markdown-tables . Install these two packages with pip . pip install recommonmark sphinx-markdown-tables Sphinx Configuration You must include these two new extensions in your sphinx documentation. Open the source/conf.py configuration file that Sphinx uses to load extensions, and add both of these to the list called extensions . extensions = [ ... 'recommonmark', 'sphinx_markdown_tables' ] Manual Method If you don't mind running yamldoc every time you change a YAML file, you can run it manually. Since yamldoc prints to STDOUT by default, just create the documentation and pipe it to a convenient file: yamldoc your/yaml/file.yaml > docs/source/parameters.md Be sure to include this in the table of contents (TOC) of your project (typically docs/source/index.rst )! Automatic Method If you've made it this far, you're probably in search of a \"set it and forget it\" method. I will be the first to admit that this is a bit hack-y, but it hasn't broken for me yet. Until I make a real Sphinx extension, edit the docs/Makefile in your favourite text editor. The last line should look something like this: %: Makefile @$(SPHINXBUILD) -M $@ \"$(SOURCEDIR)\" \"$(BUILDDIR)\" $(SPHINXOPTS) $(O) Simply add a file to generate your parameters.md file with yamldoc before any building is done with Sphinx. %: Makefile yamldoc your/yaml/file.yaml > source/parameters.md` @$(SPHINXBUILD) -M $@ \"$(SOURCEDIR)\" \"$(BUILDDIR)\" $(SPHINXOPTS) $(O) Remember to include this new file in the table of contents (TOC) for your project (typically docs/source/index.rst )! For more details on how to document YAML files with yamldoc , see the tutorials .","title":"Sphinx Integration"},{"location":"sphinx/#sphinx-integration","text":"A primary motivation for yamldoc was to generate documentation for YAML configuration files dynamically, in order that documentation does not outpace development. I have plans to include yamldoc in a Sphinx extension in the future, but for now there is a simple way to generate your parameter references with each build of the documentation.","title":"Sphinx Integration"},{"location":"sphinx/#sphinx-setup","text":"For this example, we have chosen to place our Sphinx documentation in the docs/ folder. Inside this folder is a directory for the source scripts, a directory for the built HTML files (if building a website), and a Makefile . You must first install some sort of Markdown parser so that the markdown that is produced from yamldoc can be understood by Sphinx. For this we recommend recommonmark . Since there is no support for markdown style tables in this package, you have to also install sphinx-markdown-tables . Install these two packages with pip . pip install recommonmark sphinx-markdown-tables","title":"Sphinx Setup"},{"location":"sphinx/#sphinx-configuration","text":"You must include these two new extensions in your sphinx documentation. Open the source/conf.py configuration file that Sphinx uses to load extensions, and add both of these to the list called extensions . extensions = [ ... 'recommonmark', 'sphinx_markdown_tables' ]","title":"Sphinx Configuration"},{"location":"sphinx/#manual-method","text":"If you don't mind running yamldoc every time you change a YAML file, you can run it manually. Since yamldoc prints to STDOUT by default, just create the documentation and pipe it to a convenient file: yamldoc your/yaml/file.yaml > docs/source/parameters.md Be sure to include this in the table of contents (TOC) of your project (typically docs/source/index.rst )!","title":"Manual Method"},{"location":"sphinx/#automatic-method","text":"If you've made it this far, you're probably in search of a \"set it and forget it\" method. I will be the first to admit that this is a bit hack-y, but it hasn't broken for me yet. Until I make a real Sphinx extension, edit the docs/Makefile in your favourite text editor. The last line should look something like this: %: Makefile @$(SPHINXBUILD) -M $@ \"$(SOURCEDIR)\" \"$(BUILDDIR)\" $(SPHINXOPTS) $(O) Simply add a file to generate your parameters.md file with yamldoc before any building is done with Sphinx. %: Makefile yamldoc your/yaml/file.yaml > source/parameters.md` @$(SPHINXBUILD) -M $@ \"$(SOURCEDIR)\" \"$(BUILDDIR)\" $(SPHINXOPTS) $(O) Remember to include this new file in the table of contents (TOC) for your project (typically docs/source/index.rst )! For more details on how to document YAML files with yamldoc , see the tutorials .","title":"Automatic Method"},{"location":"tutorial/","text":"Tutorials The following tutorials assumes knowledge of how to interact with files in a command line environment. Otherwise, basic Linux skills and an understanding of Python syntax will be an asset. Flat YAML The most common use case for this software will be to generate configuration for a flat file of configuration options. In this case, there are many parameters, each with a name, and a value. See below for a minimal example. #' Here is some meta data. meta: \"Data\" #' And here is #' some more #' split over #' a couple of lines. fun: True Each value has a name, a colon, and a value. Above each value we have given meta data in a comment with a specific prefix #' . This can be whatever character you want, so long as it is consistent. You can give different prefix characters with the -c flag. To create a report from this file, point yamldoc to it. yamldoc test/yaml/basic.yaml Which gives Configuration Parameters Reference Any information about this page goes here. Key Value Information meta \"Data\" Here is some meta data. fun True And here is some more split over a couple of lines. Generated by yamldoc v0.1.2 on 2020-10-06 Notice how yamldoc intelligently joins and wraps long comments to fit inside the table. In later tutorials, we will see how to extend this and automatically embed the results in Sphinx documentation.","title":"YAML"},{"location":"tutorial/#tutorials","text":"The following tutorials assumes knowledge of how to interact with files in a command line environment. Otherwise, basic Linux skills and an understanding of Python syntax will be an asset.","title":"Tutorials"},{"location":"tutorial/#flat-yaml","text":"The most common use case for this software will be to generate configuration for a flat file of configuration options. In this case, there are many parameters, each with a name, and a value. See below for a minimal example. #' Here is some meta data. meta: \"Data\" #' And here is #' some more #' split over #' a couple of lines. fun: True Each value has a name, a colon, and a value. Above each value we have given meta data in a comment with a specific prefix #' . This can be whatever character you want, so long as it is consistent. You can give different prefix characters with the -c flag. To create a report from this file, point yamldoc to it. yamldoc test/yaml/basic.yaml Which gives","title":"Flat YAML"},{"location":"tutorial/#configuration-parameters-reference","text":"Any information about this page goes here. Key Value Information meta \"Data\" Here is some meta data. fun True And here is some more split over a couple of lines. Generated by yamldoc v0.1.2 on 2020-10-06 Notice how yamldoc intelligently joins and wraps long comments to fit inside the table. In later tutorials, we will see how to extend this and automatically embed the results in Sphinx documentation.","title":"Configuration Parameters Reference"},{"location":"tutorial_1/","text":"YAML with Schema A developer can choose to additionally validate the input that a user gives in a YAML file through a schema. For more information on the version of schema that is implemented here, see the documentation . Here is an example of a schema file for the above example. $schema: \"http://json-schema.org/draft-04/schema#\" type: object properties: meta: type: string fun: type: bool A schema must contain a link to the original definition, here given as a link, and a description of each variable. In this case, the schema is simple. It is describing an object with two properties (variables), meta , and fun . It succinctly gives the expected type declaration for these variables, which can be validated at run time. To include this in the above report with yamldoc , set the -s flag. yamldoc test/yaml/basic.yaml -s test/schema/basic.schema Which outputs: Configuration Parameters Reference Any information about this page goes here. Key Value Type Information meta \"Data\" string Here is some meta data. fun True bool And here is some more split over a couple of lines. Generated by yamldoc v0.1.2 on 2020-10-06 The difference between these two reports is the inclusion of the Type column. Modifying the Title and Description Though the title and description of this page can easily be edited after it is generated, we also include a special declaration in the schema file to modify these easily. Edit the schema file from before and add the following lines: $schema: \"http://json-schema.org/draft-04/schema#\" _yamldoc_title: My Awesome Title _yamldoc_description: This can be a long string or paragraph talking about your parameters and describing how to use them. You can use line breaks too, you just have to write them manually.<br><br> Isn't that cool? type: object properties: meta: type: string fun: type: bool Which gives My Awesome Title This can be a long string or paragraph talking about your parameters and describing how to use them. You can use line breaks too, you just have to write them manually. Isn't that cool? Key Value Type Information meta \"Data\" string Here is some meta data. fun True bool And here is some more split over a couple of lines. Generated by yamldoc v0.1.2 on 2020-10-06","title":"YAML with Schema"},{"location":"tutorial_1/#yaml-with-schema","text":"A developer can choose to additionally validate the input that a user gives in a YAML file through a schema. For more information on the version of schema that is implemented here, see the documentation . Here is an example of a schema file for the above example. $schema: \"http://json-schema.org/draft-04/schema#\" type: object properties: meta: type: string fun: type: bool A schema must contain a link to the original definition, here given as a link, and a description of each variable. In this case, the schema is simple. It is describing an object with two properties (variables), meta , and fun . It succinctly gives the expected type declaration for these variables, which can be validated at run time. To include this in the above report with yamldoc , set the -s flag. yamldoc test/yaml/basic.yaml -s test/schema/basic.schema Which outputs:","title":"YAML with Schema"},{"location":"tutorial_1/#configuration-parameters-reference","text":"Any information about this page goes here. Key Value Type Information meta \"Data\" string Here is some meta data. fun True bool And here is some more split over a couple of lines. Generated by yamldoc v0.1.2 on 2020-10-06 The difference between these two reports is the inclusion of the Type column.","title":"Configuration Parameters Reference"},{"location":"tutorial_1/#modifying-the-title-and-description","text":"Though the title and description of this page can easily be edited after it is generated, we also include a special declaration in the schema file to modify these easily. Edit the schema file from before and add the following lines: $schema: \"http://json-schema.org/draft-04/schema#\" _yamldoc_title: My Awesome Title _yamldoc_description: This can be a long string or paragraph talking about your parameters and describing how to use them. You can use line breaks too, you just have to write them manually.<br><br> Isn't that cool? type: object properties: meta: type: string fun: type: bool Which gives","title":"Modifying the Title and Description"},{"location":"tutorial_1/#my-awesome-title","text":"This can be a long string or paragraph talking about your parameters and describing how to use them. You can use line breaks too, you just have to write them manually. Isn't that cool? Key Value Type Information meta \"Data\" string Here is some meta data. fun True bool And here is some more split over a couple of lines. Generated by yamldoc v0.1.2 on 2020-10-06","title":"My Awesome Title"},{"location":"api/classes/","text":"Entry Container for a single YAML key value pairing and associated metadata. __init__ ( self , key , value , meta ) special Initialize the object Parameters: Name Type Description Default key Name of the value required value Given value. required meta Any associated comments or meta data. required Source code in yamldoc/entries.py def __init__ ( self , key , value , meta ): \"\"\" Initialize the object Arguments: key: Name of the value value: Given value. meta: Any associated comments or meta data. \"\"\" self . key = key self . value = value self . meta = meta self . isBase = False self . type = None __repr__ ( self ) special Gives a print representation for the class. Source code in yamldoc/entries.py def __repr__ ( self ): \"\"\" Gives a print representation for the class. \"\"\" if self . type is not None : return f 'YAML Entry [ { self . key } : { self . value } ] \\n\\t Meta: { self . meta } \\n\\t Type: { self . type } ' else : return f 'YAML Entry [ { self . key } : { self . value } ] \\n\\t Meta: { self . meta } ' to_markdown ( self , schema = False ) Prints the entry as markdown. Parameters: Name Type Description Default schema Print with four columns instead of three. False Source code in yamldoc/entries.py def to_markdown ( self , schema = False ): \"\"\" Prints the entry as markdown. Arguments: schema: Print with four columns instead of three. \"\"\" if schema : m = '<br />' . join ( textwrap . wrap ( self . meta , width = 50 )) if self . type == None : vartype = \"Unknown\" else : vartype = self . type return f '| ` { self . key } ` | ` { self . value } ` | { vartype } | { m } | \\n ' else : m = '<br />' . join ( textwrap . wrap ( self . meta , width = 50 )) return f '| ` { self . key } ` | ` { self . value } ` | { m } | \\n ' MetaEntry A container to hold a base level YAML entry plus any associated hierarchical keys and values. __init__ ( self , name , meta ) special Initialize the object. Parameters: Name Type Description Default name Name of the value. required meta Comments derived from YAML file. required Source code in yamldoc/entries.py def __init__ ( self , name , meta ): \"\"\" Initialize the object. Arguments: name: Name of the value. meta: Comments derived from YAML file. \"\"\" self . name = name self . meta = meta self . isBase = True self . entries = [] self . has_schema = False __repr__ ( self ) special Returns a print representation. Source code in yamldoc/entries.py def __repr__ ( self ): \"\"\" Returns a print representation. \"\"\" if self . has_schema : return f 'YAML Meta Object with { len ( self . entries ) } entries [ { self . name } ] and type information.' else : return f 'YAML Meta Object with { len ( self . entries ) } entries [ { self . name } ]' to_markdown ( self , schema = False ) Prints the contents of the object in markdown. !!! argumenets schema: Print with four columns instead of three. Source code in yamldoc/entries.py def to_markdown ( self , schema = False ): \"\"\" Prints the contents of the object in markdown. Argumenets: schema: Print with four columns instead of three. \"\"\" if schema : output = f '## ` { self . name } ` \\n\\n { self . meta } \\n\\n ' output += \"### Member variables: \\n\\n \" output += \"| Key | Value | Type | Information | \\n \" output += \"| :-: | :-: | :-: | :-- | \\n \" for entry in self . entries : output += entry . to_markdown ( schema ) output += \" \\n\\n \" return output else : output = f '## ` { self . name } ` \\n\\n { self . meta } \\n\\n ' output += \"### Member variables: \\n\\n \" output += \"| Key | Value | Information | \\n \" output += \"| :-: | :-: | :-- | \\n \" for entry in self . entries : output += entry . to_markdown () output += \" \\n\\n \" return output","title":"Classes"},{"location":"api/classes/#yamldoc.entries","text":"","title":"yamldoc.entries"},{"location":"api/classes/#yamldoc.entries.Entry","text":"Container for a single YAML key value pairing and associated metadata.","title":"Entry"},{"location":"api/classes/#yamldoc.entries.Entry.__init__","text":"Initialize the object Parameters: Name Type Description Default key Name of the value required value Given value. required meta Any associated comments or meta data. required Source code in yamldoc/entries.py def __init__ ( self , key , value , meta ): \"\"\" Initialize the object Arguments: key: Name of the value value: Given value. meta: Any associated comments or meta data. \"\"\" self . key = key self . value = value self . meta = meta self . isBase = False self . type = None","title":"__init__()"},{"location":"api/classes/#yamldoc.entries.Entry.__repr__","text":"Gives a print representation for the class. Source code in yamldoc/entries.py def __repr__ ( self ): \"\"\" Gives a print representation for the class. \"\"\" if self . type is not None : return f 'YAML Entry [ { self . key } : { self . value } ] \\n\\t Meta: { self . meta } \\n\\t Type: { self . type } ' else : return f 'YAML Entry [ { self . key } : { self . value } ] \\n\\t Meta: { self . meta } '","title":"__repr__()"},{"location":"api/classes/#yamldoc.entries.Entry.to_markdown","text":"Prints the entry as markdown. Parameters: Name Type Description Default schema Print with four columns instead of three. False Source code in yamldoc/entries.py def to_markdown ( self , schema = False ): \"\"\" Prints the entry as markdown. Arguments: schema: Print with four columns instead of three. \"\"\" if schema : m = '<br />' . join ( textwrap . wrap ( self . meta , width = 50 )) if self . type == None : vartype = \"Unknown\" else : vartype = self . type return f '| ` { self . key } ` | ` { self . value } ` | { vartype } | { m } | \\n ' else : m = '<br />' . join ( textwrap . wrap ( self . meta , width = 50 )) return f '| ` { self . key } ` | ` { self . value } ` | { m } | \\n '","title":"to_markdown()"},{"location":"api/classes/#yamldoc.entries.MetaEntry","text":"A container to hold a base level YAML entry plus any associated hierarchical keys and values.","title":"MetaEntry"},{"location":"api/classes/#yamldoc.entries.MetaEntry.__init__","text":"Initialize the object. Parameters: Name Type Description Default name Name of the value. required meta Comments derived from YAML file. required Source code in yamldoc/entries.py def __init__ ( self , name , meta ): \"\"\" Initialize the object. Arguments: name: Name of the value. meta: Comments derived from YAML file. \"\"\" self . name = name self . meta = meta self . isBase = True self . entries = [] self . has_schema = False","title":"__init__()"},{"location":"api/classes/#yamldoc.entries.MetaEntry.__repr__","text":"Returns a print representation. Source code in yamldoc/entries.py def __repr__ ( self ): \"\"\" Returns a print representation. \"\"\" if self . has_schema : return f 'YAML Meta Object with { len ( self . entries ) } entries [ { self . name } ] and type information.' else : return f 'YAML Meta Object with { len ( self . entries ) } entries [ { self . name } ]'","title":"__repr__()"},{"location":"api/classes/#yamldoc.entries.MetaEntry.to_markdown","text":"Prints the contents of the object in markdown. !!! argumenets schema: Print with four columns instead of three. Source code in yamldoc/entries.py def to_markdown ( self , schema = False ): \"\"\" Prints the contents of the object in markdown. Argumenets: schema: Print with four columns instead of three. \"\"\" if schema : output = f '## ` { self . name } ` \\n\\n { self . meta } \\n\\n ' output += \"### Member variables: \\n\\n \" output += \"| Key | Value | Type | Information | \\n \" output += \"| :-: | :-: | :-: | :-- | \\n \" for entry in self . entries : output += entry . to_markdown ( schema ) output += \" \\n\\n \" return output else : output = f '## ` { self . name } ` \\n\\n { self . meta } \\n\\n ' output += \"### Member variables: \\n\\n \" output += \"| Key | Value | Information | \\n \" output += \"| :-: | :-: | :-- | \\n \" for entry in self . entries : output += entry . to_markdown () output += \" \\n\\n \" return output","title":"to_markdown()"},{"location":"api/main/","text":"add_type_metadata ( schema , yaml , debug = False ) Modified a list of yaml entries in place to add type information from a parsed schema. Parameters: Name Type Description Default schema List of schema representations from parse_schema. required yaml List of yaml representations from parse_yaml. required debug Print debug information False Returns: Nothing. Source code in yamldoc/parser.py def add_type_metadata ( schema , yaml , debug = False ): ''' Modified a list of yaml entries in place to add type information from a parsed schema. Arguments: schema: List of schema representations from parse_schema. yaml: List of yaml representations from parse_yaml. debug: Print debug information Returns: Nothing. ''' # Loop over each value of the schema for name , variables in schema . items (): # Find the corresponding entry in the YAML. # Special case: if the name is base in the schema # these are top level variables # which need to be dealt with seperately. if name == \"base\" : # Look for top level entries for var , var_type in variables . items (): for value in yaml : if not value . isBase : if var == value . key : value . type = var_type else : for value in yaml : if value . isBase : if name == value . name : for var , var_type in variables . items (): for entry in value . entries : if var == entry . key : if debug : print ( f \"Setting type of { var } \" ) entry . type = var_type # If we find at least one # then we can say that # there's a schema. value . has_schema = True entry . has_schema = True count_indent ( line ) Count indentation level. Parameters: Name Type Description Default line A character string to be processed. required Source code in yamldoc/parser.py def count_indent ( line ): ''' Count indentation level. Arguments: line: A character string to be processed. ''' return len ( line ) - len ( line . lstrip ( ' ' )) key_value ( line ) Extract a key value pair from a single YAML line. Parameters: Name Type Description Default line A character string to be processed. required Returns: Type Description Key value pairing; alternatively, if not value i present, just the key. Source code in yamldoc/parser.py def key_value ( line ): ''' Extract a key value pair from a single YAML line. Arguments: line: A character string to be processed. Returns: Key value pairing; alternatively, if not value i present, just the key. ''' try : key , value = line . rstrip () . lstrip ( ' ' ) . split ( \":\" ) except ValueError : values = line . rstrip () . lstrip ( ' ' ) . split ( \":\" ) key = values [ 0 ] value = '' . join ( values [ 1 :]) if not value : return ( key ) return ( key , value . lstrip ( \" \" )) main ( yaml_path , char = \"#'\" , debug = False , schema_path = None , title = 'Configuration Parameters Reference' , description = 'Any information about this page goes here.' ) Takes a given YAML file and optionally an associated schema, parsing each for their key value pairings and reports the results as a markdown document. Parameters: Name Type Description Default yaml_path Path to YAML file. required schema_path Path to schema file. None char Special character to identify comments to be included in YAMLDOC documentation. \"#'\" debug Print debug information False title Title of markdown generated. 'Configuration Parameters Reference' description Description given below the title in markdown. 'Any information about this page goes here.' Returns: Nothing, prints to stdout. Source code in yamldoc/parser.py def main ( yaml_path , char = \"#'\" , debug = False , schema_path = None , title = \"Configuration Parameters Reference\" , description = \"Any information about this page goes here.\" ): ''' Takes a given YAML file and optionally an associated schema, parsing each for their key value pairings and reports the results as a markdown document. Arguments: yaml_path: Path to YAML file. schema_path: Path to schema file. char: Special character to identify comments to be included in YAMLDOC documentation. debug: Print debug information title: Title of markdown generated. description: Description given below the title in markdown. Returns: Nothing, prints to stdout. ''' # If a schema has been specified, add the # type information to the rest of the # variables. if schema_path is not None : schema , specials = parse_schema ( schema_path , debug ) yaml = parse_yaml ( yaml_path , char , debug ) # Edit the yaml in place with type information. add_type_metadata ( schema , yaml , debug ) if \"_yamldoc_title\" in specials : title = specials [ \"_yamldoc_title\" ] if \"_yamldoc_description\" in specials : description = specials [ \"_yamldoc_description\" ] # And do the printing print ( \"# \" + title + \" \\n\\n \" + description + \" \\n \" ) # Build the table with top level yaml print ( \"| Key | Value | Type | Information |\" ) print ( \"| :-: | :-: | :-: | :-- |\" ) for value in yaml : if not value . isBase : print ( value . to_markdown ( schema = True )) print ( \" \\n\\n \" ) for value in yaml : if value . isBase : print ( value . to_markdown ( schema = True )) print ( f \"--- \\n Generated by [yamldoc](https://github.com/chris1221/yaml.doc) v { yamldoc . __version__ } on { date . today () } \" ) else : print ( \"# \" + title + \" \\n\\n \" + description + \" \\n \" ) yaml = parse_yaml ( yaml_path , char , debug ) # Build the table with top level yaml print ( \"| Key | Value | Information |\" ) print ( \"| :-: | :-: | :-- |\" ) for value in yaml : if not value . isBase : print ( value . to_markdown ()) print ( \" \\n\\n \" ) for value in yaml : if value . isBase : print ( value . to_markdown ()) print ( f \"--- \\n Generated by [yamldoc](https://github.com/chris1221/yaml.doc) v { yamldoc . __version__ } on { date . today () } \" ) parse_schema ( path_to_file , debug = False ) Parse a schema file to identify key value pairing of values and their associated types. Parameters: Name Type Description Default path_to_file Path to schema file. required Returns: Tuple of (schema, specials) where specials are unique YAMLDOC strings for the title and description of the desired markdown. Source code in yamldoc/parser.py def parse_schema ( path_to_file , debug = False ): ''' Parse a schema file to identify key value pairing of values and their associated types. Arguments: path_to_file: Path to schema file. Returns: Tuple of (schema, specials) where specials are unique YAMLDOC strings for the title and description of the desired markdown. ''' name = \"base\" indent = [ 0 , 0 ] specials = {} indents = {} current = {} special_type_case = False with open ( path_to_file ) as schema : for line in [ l for l in schema . readlines () if l . rstrip ()]: if debug : print ( line ) indent = [ indent [ 1 ], count_indent ( line )] # The base level has to start with a special name # because it is not named in the schema. try : key , value = key_value ( line ) except ValueError : key = key_value ( line ) value = None # This is awkwardly placed but we have to deal # with a special case where lines # start with a dash, and indicate that # variables have multiple types. # # If this has been observed further inside the # loop, and the line does indeed start with a dash if special_type_case : # If the indent has decreased, then # the list of types has finished. if indent [ 1 ] < indent [ 0 ]: special_type_case = False continue if line . lstrip ( \" \" ) . startswith ( \"-\" ): value = line . lstrip ( \" \" ) . lstrip ( \"- \" ) . rstrip () current [ parent ][ name ] . append ( value ) continue else : raise TypeError ( \"You must specify a value for type.\" ) # < Deal with top level specials. if key == \"$schema\" : assert value is not None specials [ \"schema\" ] = value if key == \"_yamldoc_title\" : assert value is not None specials [ key ] = value if key == \"_yamldoc_description\" : assert value is not None specials [ key ] = value if key == \"description\" : assert value is not None specials [ \"description\" ] = value # /> # Top level properties option if value is None : if key == \"properties\" : current [ name ] = {} indents [ name ] = {} continue # Deal with increasing indent levels # The actual amount of indent is not # relevant (though it may be for # parsing a valid YAML document. if indent [ 1 ] > indent [ 0 ]: if value is None : # If the key is properties # then we are starting a new object # definition. if key == \"properties\" : current [ name ] = {} indents [ name ] = {} continue # This is a special case where # there can be multiple types # given for a particular variable. elif key == \"type\" : current [ parent ][ name ] = [] indents [ parent ][ name ] = [] special_type_case = True continue # Otherwise, its the name of the # actual object. # Assign the key to be the \"name\" # and relegate the previous name # to the \"parent\". else : parent = name name = key continue # If it's giving the type of the object # then store that under the parent (meta) # object along with its indentation level. if key == \"type\" : assert value is not None if value != \"object\" : current [ parent ][ name ] = value indents [ parent ][ name ] = indent [ 1 ] continue if indent [ 1 ] < indent [ 0 ]: # We're just adding another value if indent [ 1 ] == indents [ parent ][ name ]: if value is None : name = key continue elif indent [ 1 ] < indents [ parent ][ name ]: if value is None : name = key continue return current , specials parse_yaml ( file_path , char = \"#'\" , debug = False ) Parse a YAML file and return a list of YAML classes. Parameters: Name Type Description Default file_path Path to the YAML file. required char A character string used to identify yamldoc blocks. \"#'\" debug Print debug information False Returns: Type Description List of YAML blocks. Source code in yamldoc/parser.py def parse_yaml ( file_path , char = \"#'\" , debug = False ): ''' Parse a YAML file and return a list of YAML classes. Arguments: file_path: Path to the YAML file. char: A character string used to identify yamldoc blocks. debug: Print debug information Return: List of YAML blocks. ''' # YAML files have key value pairings seperated by # newlines. The most straightforward kind of things to parse will be # keyvalue pairs preceeded by comments with the Doxygen marker #' current_entry = None meta = \"\" things = [] with open ( file_path ) as yaml : for line in [ l for l in yaml . readlines () if l . rstrip ()]: if debug : print ( line . rstrip ()) # Either we haven't started yet # or we've just flushed the entry. if current_entry is None : # Find the number of leading spaces. # YAML only uses spaces. nspaces = len ( line ) - len ( line . lstrip ( ' ' )) if debug : print ( \"@ \\t Found \" + str ( nspaces ) + \" indent level.\" ) if nspaces == 0 : current_entry = None if line . startswith ( char ): meta = meta + line . lstrip ( char ) . rstrip () else : key , value = line . rstrip () . split ( \":\" ) # If there is no value, this is the beginning of a # base entry (i.e. there are subentries to follow) if not value . lstrip (): current_entry = yamldoc . entries . MetaEntry ( key , meta ) if debug : print ( \"@ \\t Found a meta entry.\" ) continue # Otherwise continue on. else : things . append ( yamldoc . entries . Entry ( key , value . lstrip ( ' ' ), meta . lstrip ())) if debug : print ( \"@ \\t Found an entry.\" ) meta = \"\" if current_entry is not None : if current_entry . isBase : # If we're back at 0 indentation, the # block is done and we need to quit. if len ( line ) - len ( line . lstrip ( ' ' )) == 0 : things . append ( current_entry ) current_entry = None continue # If not, continue parsing the sub entries. if line . lstrip ( ' ' ) . startswith ( char ): meta = meta + line . lstrip () . lstrip ( char ) . rstrip () else : key , value = line . lstrip () . rstrip () . split ( \":\" ) current_entry . entries . append ( yamldoc . entries . Entry ( key , value . lstrip ( ' ' ), meta . lstrip ())) if debug : print ( \"@ \\t Found an entry and deposited it in meta.\" ) meta = \"\" # The file might run out # before the final meta # entry is added. try : if current_entry . isBase : things . append ( current_entry ) except AttributeError : pass return things","title":"Functions"},{"location":"api/main/#yamldoc.parser","text":"","title":"yamldoc.parser"},{"location":"api/main/#yamldoc.parser.add_type_metadata","text":"Modified a list of yaml entries in place to add type information from a parsed schema. Parameters: Name Type Description Default schema List of schema representations from parse_schema. required yaml List of yaml representations from parse_yaml. required debug Print debug information False Returns: Nothing. Source code in yamldoc/parser.py def add_type_metadata ( schema , yaml , debug = False ): ''' Modified a list of yaml entries in place to add type information from a parsed schema. Arguments: schema: List of schema representations from parse_schema. yaml: List of yaml representations from parse_yaml. debug: Print debug information Returns: Nothing. ''' # Loop over each value of the schema for name , variables in schema . items (): # Find the corresponding entry in the YAML. # Special case: if the name is base in the schema # these are top level variables # which need to be dealt with seperately. if name == \"base\" : # Look for top level entries for var , var_type in variables . items (): for value in yaml : if not value . isBase : if var == value . key : value . type = var_type else : for value in yaml : if value . isBase : if name == value . name : for var , var_type in variables . items (): for entry in value . entries : if var == entry . key : if debug : print ( f \"Setting type of { var } \" ) entry . type = var_type # If we find at least one # then we can say that # there's a schema. value . has_schema = True entry . has_schema = True","title":"add_type_metadata()"},{"location":"api/main/#yamldoc.parser.count_indent","text":"Count indentation level. Parameters: Name Type Description Default line A character string to be processed. required Source code in yamldoc/parser.py def count_indent ( line ): ''' Count indentation level. Arguments: line: A character string to be processed. ''' return len ( line ) - len ( line . lstrip ( ' ' ))","title":"count_indent()"},{"location":"api/main/#yamldoc.parser.key_value","text":"Extract a key value pair from a single YAML line. Parameters: Name Type Description Default line A character string to be processed. required Returns: Type Description Key value pairing; alternatively, if not value i present, just the key. Source code in yamldoc/parser.py def key_value ( line ): ''' Extract a key value pair from a single YAML line. Arguments: line: A character string to be processed. Returns: Key value pairing; alternatively, if not value i present, just the key. ''' try : key , value = line . rstrip () . lstrip ( ' ' ) . split ( \":\" ) except ValueError : values = line . rstrip () . lstrip ( ' ' ) . split ( \":\" ) key = values [ 0 ] value = '' . join ( values [ 1 :]) if not value : return ( key ) return ( key , value . lstrip ( \" \" ))","title":"key_value()"},{"location":"api/main/#yamldoc.parser.main","text":"Takes a given YAML file and optionally an associated schema, parsing each for their key value pairings and reports the results as a markdown document. Parameters: Name Type Description Default yaml_path Path to YAML file. required schema_path Path to schema file. None char Special character to identify comments to be included in YAMLDOC documentation. \"#'\" debug Print debug information False title Title of markdown generated. 'Configuration Parameters Reference' description Description given below the title in markdown. 'Any information about this page goes here.' Returns: Nothing, prints to stdout. Source code in yamldoc/parser.py def main ( yaml_path , char = \"#'\" , debug = False , schema_path = None , title = \"Configuration Parameters Reference\" , description = \"Any information about this page goes here.\" ): ''' Takes a given YAML file and optionally an associated schema, parsing each for their key value pairings and reports the results as a markdown document. Arguments: yaml_path: Path to YAML file. schema_path: Path to schema file. char: Special character to identify comments to be included in YAMLDOC documentation. debug: Print debug information title: Title of markdown generated. description: Description given below the title in markdown. Returns: Nothing, prints to stdout. ''' # If a schema has been specified, add the # type information to the rest of the # variables. if schema_path is not None : schema , specials = parse_schema ( schema_path , debug ) yaml = parse_yaml ( yaml_path , char , debug ) # Edit the yaml in place with type information. add_type_metadata ( schema , yaml , debug ) if \"_yamldoc_title\" in specials : title = specials [ \"_yamldoc_title\" ] if \"_yamldoc_description\" in specials : description = specials [ \"_yamldoc_description\" ] # And do the printing print ( \"# \" + title + \" \\n\\n \" + description + \" \\n \" ) # Build the table with top level yaml print ( \"| Key | Value | Type | Information |\" ) print ( \"| :-: | :-: | :-: | :-- |\" ) for value in yaml : if not value . isBase : print ( value . to_markdown ( schema = True )) print ( \" \\n\\n \" ) for value in yaml : if value . isBase : print ( value . to_markdown ( schema = True )) print ( f \"--- \\n Generated by [yamldoc](https://github.com/chris1221/yaml.doc) v { yamldoc . __version__ } on { date . today () } \" ) else : print ( \"# \" + title + \" \\n\\n \" + description + \" \\n \" ) yaml = parse_yaml ( yaml_path , char , debug ) # Build the table with top level yaml print ( \"| Key | Value | Information |\" ) print ( \"| :-: | :-: | :-- |\" ) for value in yaml : if not value . isBase : print ( value . to_markdown ()) print ( \" \\n\\n \" ) for value in yaml : if value . isBase : print ( value . to_markdown ()) print ( f \"--- \\n Generated by [yamldoc](https://github.com/chris1221/yaml.doc) v { yamldoc . __version__ } on { date . today () } \" )","title":"main()"},{"location":"api/main/#yamldoc.parser.parse_schema","text":"Parse a schema file to identify key value pairing of values and their associated types. Parameters: Name Type Description Default path_to_file Path to schema file. required Returns: Tuple of (schema, specials) where specials are unique YAMLDOC strings for the title and description of the desired markdown. Source code in yamldoc/parser.py def parse_schema ( path_to_file , debug = False ): ''' Parse a schema file to identify key value pairing of values and their associated types. Arguments: path_to_file: Path to schema file. Returns: Tuple of (schema, specials) where specials are unique YAMLDOC strings for the title and description of the desired markdown. ''' name = \"base\" indent = [ 0 , 0 ] specials = {} indents = {} current = {} special_type_case = False with open ( path_to_file ) as schema : for line in [ l for l in schema . readlines () if l . rstrip ()]: if debug : print ( line ) indent = [ indent [ 1 ], count_indent ( line )] # The base level has to start with a special name # because it is not named in the schema. try : key , value = key_value ( line ) except ValueError : key = key_value ( line ) value = None # This is awkwardly placed but we have to deal # with a special case where lines # start with a dash, and indicate that # variables have multiple types. # # If this has been observed further inside the # loop, and the line does indeed start with a dash if special_type_case : # If the indent has decreased, then # the list of types has finished. if indent [ 1 ] < indent [ 0 ]: special_type_case = False continue if line . lstrip ( \" \" ) . startswith ( \"-\" ): value = line . lstrip ( \" \" ) . lstrip ( \"- \" ) . rstrip () current [ parent ][ name ] . append ( value ) continue else : raise TypeError ( \"You must specify a value for type.\" ) # < Deal with top level specials. if key == \"$schema\" : assert value is not None specials [ \"schema\" ] = value if key == \"_yamldoc_title\" : assert value is not None specials [ key ] = value if key == \"_yamldoc_description\" : assert value is not None specials [ key ] = value if key == \"description\" : assert value is not None specials [ \"description\" ] = value # /> # Top level properties option if value is None : if key == \"properties\" : current [ name ] = {} indents [ name ] = {} continue # Deal with increasing indent levels # The actual amount of indent is not # relevant (though it may be for # parsing a valid YAML document. if indent [ 1 ] > indent [ 0 ]: if value is None : # If the key is properties # then we are starting a new object # definition. if key == \"properties\" : current [ name ] = {} indents [ name ] = {} continue # This is a special case where # there can be multiple types # given for a particular variable. elif key == \"type\" : current [ parent ][ name ] = [] indents [ parent ][ name ] = [] special_type_case = True continue # Otherwise, its the name of the # actual object. # Assign the key to be the \"name\" # and relegate the previous name # to the \"parent\". else : parent = name name = key continue # If it's giving the type of the object # then store that under the parent (meta) # object along with its indentation level. if key == \"type\" : assert value is not None if value != \"object\" : current [ parent ][ name ] = value indents [ parent ][ name ] = indent [ 1 ] continue if indent [ 1 ] < indent [ 0 ]: # We're just adding another value if indent [ 1 ] == indents [ parent ][ name ]: if value is None : name = key continue elif indent [ 1 ] < indents [ parent ][ name ]: if value is None : name = key continue return current , specials","title":"parse_schema()"},{"location":"api/main/#yamldoc.parser.parse_yaml","text":"Parse a YAML file and return a list of YAML classes. Parameters: Name Type Description Default file_path Path to the YAML file. required char A character string used to identify yamldoc blocks. \"#'\" debug Print debug information False Returns: Type Description List of YAML blocks. Source code in yamldoc/parser.py def parse_yaml ( file_path , char = \"#'\" , debug = False ): ''' Parse a YAML file and return a list of YAML classes. Arguments: file_path: Path to the YAML file. char: A character string used to identify yamldoc blocks. debug: Print debug information Return: List of YAML blocks. ''' # YAML files have key value pairings seperated by # newlines. The most straightforward kind of things to parse will be # keyvalue pairs preceeded by comments with the Doxygen marker #' current_entry = None meta = \"\" things = [] with open ( file_path ) as yaml : for line in [ l for l in yaml . readlines () if l . rstrip ()]: if debug : print ( line . rstrip ()) # Either we haven't started yet # or we've just flushed the entry. if current_entry is None : # Find the number of leading spaces. # YAML only uses spaces. nspaces = len ( line ) - len ( line . lstrip ( ' ' )) if debug : print ( \"@ \\t Found \" + str ( nspaces ) + \" indent level.\" ) if nspaces == 0 : current_entry = None if line . startswith ( char ): meta = meta + line . lstrip ( char ) . rstrip () else : key , value = line . rstrip () . split ( \":\" ) # If there is no value, this is the beginning of a # base entry (i.e. there are subentries to follow) if not value . lstrip (): current_entry = yamldoc . entries . MetaEntry ( key , meta ) if debug : print ( \"@ \\t Found a meta entry.\" ) continue # Otherwise continue on. else : things . append ( yamldoc . entries . Entry ( key , value . lstrip ( ' ' ), meta . lstrip ())) if debug : print ( \"@ \\t Found an entry.\" ) meta = \"\" if current_entry is not None : if current_entry . isBase : # If we're back at 0 indentation, the # block is done and we need to quit. if len ( line ) - len ( line . lstrip ( ' ' )) == 0 : things . append ( current_entry ) current_entry = None continue # If not, continue parsing the sub entries. if line . lstrip ( ' ' ) . startswith ( char ): meta = meta + line . lstrip () . lstrip ( char ) . rstrip () else : key , value = line . lstrip () . rstrip () . split ( \":\" ) current_entry . entries . append ( yamldoc . entries . Entry ( key , value . lstrip ( ' ' ), meta . lstrip ())) if debug : print ( \"@ \\t Found an entry and deposited it in meta.\" ) meta = \"\" # The file might run out # before the final meta # entry is added. try : if current_entry . isBase : things . append ( current_entry ) except AttributeError : pass return things","title":"parse_yaml()"}]}